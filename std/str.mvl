include "mem.mvl"

proc strlen str: s64 -> s64
  i = 0

 body:
  ptr = @add str i
  char = *s8 ptr
  if char == 0s8 jump end
  i = @add i 1
  jump body
 end:

  ret i

proc streq a: s64 b: s64 -> s64
  a_len = @strlen a
  b_len = @strlen b
  if a_len != b_len jump error

  i = 0

 body:
  if i == a_len jump end

  a_ptr = @add a i
  a_char = *s8 a_ptr
  b_ptr = @add b i
  b_char = *s8 b_ptr
  if a_char != b_char jump error

  i = @add i 1
  jump body
 end:

  ret 1

 error:
  ret 0

proc s64_to_str num: s64 -> s64
  buf_cap = 1
  buf_size = 0
  size_to_alloc = @add buf_size 1
  buf = @malloc size_to_alloc

 body:
  if buf_size < buf_cap jump next
  buf_cap = @add buf_cap 1
  size_to_alloc = @add buf_cap 1
  @realloc buf size_to_alloc
 next:

  dest = @add buf 1
  @memmove dest buf buf_size

  digit = @mod num 10
  digit = @add digit '0'
  digit_s8 = cast s8 digit
  *buf = digit_s8

  num = @div num 10
  buf_size = @add buf_size 1

  if num > 0 jump body

  ptr = @add buf buf_size
  *ptr = 0s8

  ret buf

proc str_to_s64 str: s64 -> s64
  num = 0
  is_neg = 0
  i = 0

  ptr = str
  char = *s8 str

  if char != 0s8 jump next0
  ret 0
 next0:

  if char != 45s8 jump next1 # 45 = '-'
  is_neg = 1
  i = 1
 next1:

 body:
  ptr = @add str i
  char = *s8 ptr

  _zero = '0'
  zero = cast s8 _zero
  _nine = '9'
  nine = cast s8 _nine
  if char == 0s8 jump end
  if char < zero jump continue
  if char > nine jump continue

  ptr = @add str i
  _digit = @sub char 0s8
  digit = cast s64 _digit

  num = @mul num 10
  num = @add num digit

 continue:
  i = @add i 1

  jump body
 end:

  if is_neg == 1 jump next2
  num = @neg num
 next2:

  ret num
